#算法
# 试题 算法训练 24点

暴力+DFS

注意变量定义的管控范围，我被坑了一个小时

```c
#include<stdio.h>
#include<stdbool.h>
#include<string.h>
#include<math.h>
int j = 0;
int max[9000];
bool flag[4]={true,true,true,true};//记录哪些数字已被使用
void DFS(int a,int b,int c,int d,int step,int re)
{
    if(step == 4){max[j] = re;j++;return;}//纯粹的DFS无法处理step==4的情况，因此单独讨论
    if(step == 2)//因为有括号的存在，所以在step==2时不同级的运算符之间需要组合，暴力+DFS
    {
        int temp1,temp2;
        int i;
        for (i = 0; i < 4; i++)
        {
            if(flag[i])
            {
                switch (i)
                {
                case 0:
                    temp1 = a;
                    break;
                case 1:
                    temp1 = b;
                    break;
                case 2:
                    temp1 = c;
                    break;
                case 3:
                    temp1 = d;
                    break;
                }
                break;
            }
            
        }
        for ( i++; i < 4; i++)
        {
            if(flag[i])
            {
                switch (i)
                {
                case 0:
                    temp2 = a;
                    break;
                case 1:
                    temp2 = b;
                    break;
                case 2:
                    temp2 = c;
                    break;
                case 3:
                    temp2 = d;
                    break;
                }
            }
        }
        DFS(a,b,c,d,4,re*abs(temp1-temp2));
        DFS(a,b,c,d,4,re*(temp1+temp2));
        DFS(a,b,c,d,4,re+(temp1*temp2));
        DFS(a,b,c,d,4,re-(temp1*temp2));
        if(temp1%temp2 == 0)
        {
            DFS(a,b,c,d,4,re+(temp1/temp2));
            DFS(a,b,c,d,4,re-(temp1/temp2));
        }
        if(temp2%temp1 == 0)
        {
            DFS(a,b,c,d,4,re+(temp2/temp1));
            DFS(a,b,c,d,4,re-(temp2/temp1));
        }
        
        if((temp1-temp2)!=0&&re%abs(temp1-temp2) == 0)
        {
            DFS(a,b,c,d,4,re/abs(temp1-temp2));
        }
        if(re%(temp1+temp2) == 0)
        {
            DFS(a,b,c,d,4,re/(temp1+temp2));
        }
        if(re!=0&&abs(temp1-temp2)%re == 0)
        {
            DFS(a,b,c,d,4,abs(temp1-temp2)/re);
        }
        if(re!=0&&(temp1+temp2)%re == 0)
        {
            DFS(a,b,c,d,4,(temp1+temp2)/re);
        }
    }
    int p;
    for (p = 0; p < 4; p++)
    {
        if(flag[p])
        {
            flag[p] = 0;//标记使用了的数字
            switch (p)
            {
            case 0:
                DFS(a,b,c,d,step+1,re*a);
                DFS(a,b,c,d,step+1,re+a);
                DFS(a,b,c,d,step+1,re-a);
                if(re%a == 0) DFS(a,b,c,d,step+1,re/a);
                if(re!=0&&a%re == 0) DFS(a,b,c,d,step+1,a/re);
                break;
            case 1:
                DFS(a,b,c,d,step+1,re*b);
                DFS(a,b,c,d,step+1,re+b);
                
                DFS(a,b,c,d,step+1,re-b);
                if(re%b == 0) DFS(a,b,c,d,step+1,re/b);
                if(re!=0&&b%re == 0) DFS(a,b,c,d,step+1,b/re);
                break;
            case 2:
                DFS(a,b,c,d,step+1,re*c);
                DFS(a,b,c,d,step+1,re+c);
                DFS(a,b,c,d,step+1,re-c);
                if(re%c == 0) DFS(a,b,c,d,step+1,re/c);
                if(re!=0&&c%re == 0) DFS(a,b,c,d,step+1,c/re);
                break;
            case 3:
                DFS(a,b,c,d,step+1,re*d);
                DFS(a,b,c,d,step+1,re+d);
                DFS(a,b,c,d,step+1,re-d);
                if(re%d == 0) DFS(a,b,c,d,step+1,re/d);
                if(re!=0&&d%re == 0) DFS(a,b,c,d,step+1,d/re);
                break;
            }
            flag[p] = 1;//将标记还原，方便下一轮的DFS
        }
        
    }
    
    
    
    return;
}
int main()
{
    int n;
    int a,b,c,d;
    scanf("%d",&n);
    while (n--)
    {
        int m = -1,k;
        j=0;
        memset(max,0,sizeof(max));
        scanf("%d %d %d %d",&a,&b,&c,&d);
        flag[0] = 0;//给0来确定从哪一个数开始
        DFS(a,b,c,d,1,a);
        flag[0] = 1;
        flag[1] = 0;
        DFS(a,b,c,d,1,b);
        flag[1] = 1;
        flag[2] = 0;
        DFS(a,b,c,d,1,c);
        flag[2] = 1;
        flag[3] = 0;
        DFS(a,b,c,d,1,d);
        flag[3] = 1;
        for (k = 0; k <= j; k++)
        {
            if(max[k]>m&&max[k]<=24){m = max[k];}
        }
        printf("%d\n",m);     
    }
    
    return 0;
}
```

